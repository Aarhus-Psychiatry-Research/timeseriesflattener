diff a/tasks.py b/tasks.py	(rejected hunks)
@@ -18,79 +18,126 @@ If you do not wish to use invoke you can simply delete this file.
 
 import platform
 import re
-from dataclasses import dataclass
+import shutil
 from pathlib import Path
-from typing import Optional
+from typing import List, Optional
 
 from invoke import Context, Result, task
 
+# Extract supported python versions from the pyproject.toml classifiers key
+SUPPORTED_PYTHON_VERSIONS = [
+    line.split("::")[-1].strip().replace('"', "").replace(",", "")
+    for line in Path("pyproject.toml").read_text().splitlines()
+    if "Programming Language :: Python ::" in line
+]
+
+NOT_WINDOWS = platform.system() != "Windows"
+
 
 def echo_header(msg: str):
     print(f"\n--- {msg} ---")
 
 
-@dataclass
-class Emo:
-    DO = "ðŸ¤–"
-    GOOD = "âœ…"
-    FAIL = "ðŸš¨"
-    WARN = "ðŸš§"
-    SYNC = "ðŸš‚"
-    PY = "ðŸ"
-    CLEAN = "ðŸ§¹"
-    TEST = "ðŸ§ª"
-    COMMUNICATE = "ðŸ“£"
-    EXAMINE = "ðŸ”"
+class MsgType:
+    # Emojis have to be encoded as bytes to not break the terminal on Windows
+    @property
+    def DOING(self) -> str:
+        return b"\xf0\x9f\xa4\x96".decode() if NOT_WINDOWS else "DOING:"
+
+    @property
+    def GOOD(self) -> str:
+        return b"\xe2\x9c\x85".decode() if NOT_WINDOWS else "DONE:"
+
+    @property
+    def FAIL(self) -> str:
+        return b"\xf0\x9f\x9a\xa8".decode() if NOT_WINDOWS else "FAILED:"
+
+    @property
+    def WARN(self) -> str:
+        return b"\xf0\x9f\x9a\xa7".decode() if NOT_WINDOWS else "WARNING:"
+
+    @property
+    def SYNC(self) -> str:
+        return b"\xf0\x9f\x9a\x82".decode() if NOT_WINDOWS else "SYNCING:"
+
+    @property
+    def PY(self) -> str:
+        return b"\xf0\x9f\x90\x8d".decode() if NOT_WINDOWS else ""
+
+    @property
+    def CLEAN(self) -> str:
+        return b"\xf0\x9f\xa7\xb9".decode() if NOT_WINDOWS else "CLEANING:"
+
+    @property
+    def TEST(self) -> str:
+        return b"\xf0\x9f\xa7\xaa".decode() if NOT_WINDOWS else "TESTING:"
+
+    @property
+    def COMMUNICATE(self) -> str:
+        return b"\xf0\x9f\x93\xa3".decode() if NOT_WINDOWS else "COMMUNICATING:"
+
+    @property
+    def EXAMINE(self) -> str:
+        return b"\xf0\x9f\x94\x8d".decode() if NOT_WINDOWS else "VIEWING:"
+
+
+msg_type = MsgType()
 
 
 def git_init(c: Context, branch: str = "main"):
     """Initialize a git repository if it does not exist yet."""
     # If no .git directory exits
     if not Path(".git").exists():
-        echo_header(f"{Emo.DO} Initializing Git repository")
+        echo_header(f"{msg_type.DOING} Initializing Git repository")
         c.run(f"git init -b {branch}")
         c.run("git add .")
-        c.run("git commit -m 'Initial commit'")
-        print(f"{Emo.GOOD} Git repository initialized")
+        c.run("git commit -m 'Init'")
+        print(f"{msg_type.GOOD} Git repository initialized")
     else:
-        print(f"{Emo.GOOD} Git repository already initialized")
+        print(f"{msg_type.GOOD} Git repository already initialized")
 
 
 def setup_venv(
     c: Context,
-    python_version: str,
+    python_path: str,
+    venv_name: Optional[str] = None,
 ) -> str:
-    venv_name = f'.venv{python_version.replace(".", "")}'
+    """Create a virtual environment if it does not exist yet.
+
+    Args:
+        c: The invoke context.
+        python_path: The python executable to use.
+        venv_name: The name of the virtual environment. Defaults to ".venv".
+    """
+    if venv_name is None:
+        venv_name = ".venv"
 
     if not Path(venv_name).exists():
         echo_header(
-            f"{Emo.DO} Creating virtual environment for {python_version}{Emo.PY}",
+            f"{msg_type.DOING} Creating virtual environment using {msg_type.PY}:{python_path}",
         )
-        c.run(f"python{python_version} -m venv {venv_name}")
-        print(f"{Emo.GOOD} Virtual environment created")
+        c.run(f"{python_path} -m venv {venv_name}")
+        print(f"{msg_type.GOOD} Virtual environment created")
     else:
-        print(f"{Emo.GOOD} Virtual environment already exists")
-
-    c.run(f"source {venv_name}/bin/activate")
-
+        print(f"{msg_type.GOOD} Virtual environment already exists")
     return venv_name
 
 
 def _add_commit(c: Context, msg: Optional[str] = None):
-    print("ðŸ”¨ Adding and committing changes")
+    print(f"{msg_type.DOING} Adding and committing changes")
     c.run("git add .")
 
     if msg is None:
         msg = input("Commit message: ")
 
-    c.run(f'git commit -m "{msg}"', pty=True, hide=True)
-    print("\nðŸ¤– Changes added and committed\n")
+    c.run(f'git commit -m "{msg}"', pty=NOT_WINDOWS, hide=True)
+    print(f"{msg_type.GOOD} Changes added and committed")
 
 
 def is_uncommitted_changes(c: Context) -> bool:
     git_status_result: Result = c.run(
         "git status --porcelain",
-        pty=True,
+        pty=NOT_WINDOWS,
         hide=True,
     )
 
@@ -183,77 +230,143 @@ def pre_commit(c: Context, auto_fix: bool):
     # heterogenous files under a "style: linting" commit
     if is_uncommitted_changes(c):
         print(
-            f"{Emo.WARN} Your git working directory is not clean. Stash or commit before running pre-commit.",
+            f"{msg_type.WARN} Your git working directory is not clean. Stash or commit before running pre-commit.",
         )
         exit(1)
 
-    echo_header(f"{Emo.CLEAN} Running pre-commit checks")
+    echo_header(f"{msg_type.CLEAN} Running pre-commit checks")
     pre_commit_cmd = "pre-commit run --all-files"
-    result = c.run(pre_commit_cmd, pty=True, warn=True)
+    result = c.run(pre_commit_cmd, pty=NOT_WINDOWS, warn=True)
 
     exit_if_error_in_stdout(result)
 
     if ("fixed" in result.stdout or "reformatted" in result.stdout) and auto_fix:
         _add_commit(c, msg="style: Auto-fixes from pre-commit")
 
-        print(f"{Emo.DO} Fixed errors, re-running pre-commit checks")
-        second_result = c.run(pre_commit_cmd, pty=True, warn=True)
+        print(f"{msg_type.DOING} Fixed errors, re-running pre-commit checks")
+        second_result = c.run(pre_commit_cmd, pty=NOT_WINDOWS, warn=True)
         exit_if_error_in_stdout(second_result)
     else:
         if result.return_code != 0:
-            print(f"{Emo.FAIL} Pre-commit checks failed")
+            print(f"{msg_type.FAIL} Pre-commit checks failed")
             exit(1)
 
 
+@task
 def static_type_checks(c: Context):
-    echo_header(f"{Emo.CLEAN} Running static type checks")
-    c.run("pyright .", pty=True)
+    echo_header(f"{msg_type.CLEAN} Running static type checks")
+    c.run("tox -e type", pty=NOT_WINDOWS)
 
 
 @task
-def install(c: Context):
+def install(
+    c: Context,
+    pip_args: str = "",
+    msg: bool = True,
+    venv_path: Optional[str] = None,
+):
     """Install the project in editable mode using pip install"""
-    echo_header(f"{Emo.DO} Installing project")
-    c.run("pip install -e '.[dev,tests,docs]'")
+    if msg:
+        echo_header(f"{msg_type.DOING} Installing project")
 
+    extras = ".[dev,tests,docs]" if NOT_WINDOWS else ".[dev,tests,docs]"
+    install_cmd = f"pip install -e {extras} {pip_args}"
+
+    if venv_path is not None and NOT_WINDOWS:
+        with c.prefix(f"source {venv_path}/bin/activate"):
+            c.run(install_cmd)
+            return
+
+    c.run(install_cmd)
+
+
+def get_python_path(preferred_version: str) -> Optional[str]:
+    """Get path to python executable."""
+    preferred_version_path = shutil.which(f"python{preferred_version}")
+
+    if preferred_version_path is not None:
+        return preferred_version_path
 
-@task
-def setup(c: Context, python_version: str = "3.9"):
-    """Confirm that a git repo exists and setup a virtual environment."""
-    git_init(c)
-    venv_name = setup_venv(c, python_version=python_version)
     print(
-        f"{Emo.DO} Activate your virtual environment by running: \n\n\t\t source {venv_name}/bin/activate \n",
+        f"{msg_type.WARN}: python{preferred_version} not found, continuing with default python version",
     )
-    print(f"{Emo.DO} Then install the project by running: \n\n\t\t inv install\n")
+    return shutil.which("python")
+
+
+@task
+def setup(c: Context, python_path: Optional[str] = None):
+    """Confirm that a git repo exists and setup a virtual environment.
+
+    Args:
+        c: Invoke context
+        python_path: Path to the python executable to use for the virtual environment. Uses the return value of `which python` if not provided.
+    """
+    git_init(c)
+
+    if python_path is None:
+        # get path to python executable
+        python_path = get_python_path(preferred_version="3.9")
+        if not python_path:
+            print(f"{msg_type.FAIL} Python executable not found")
+            exit(1)
+    venv_name = setup_venv(c, python_path=python_path)
+
+    install(c, pip_args="--upgrade", msg=False, venv_path=venv_name)
+
+    if venv_name is not None:
+        print(
+            f"{msg_type.DOING} Activate your virtual environment by running: \n\n\t\t source {venv_name}/bin/activate \n",
+        )
 
 
 @task
 def update(c: Context):
     """Update dependencies."""
-    echo_header(f"{Emo.DO} Updating project")
-    c.run("pip install --upgrade -e '.[dev,tests,docs]'")
+    echo_header(f"{msg_type.DOING} Updating project")
+    install(c, pip_args="--upgrade", msg=False)
 
 
-@task
-def test(c: Context):
+@task(iterable="pytest_args")
+def test(
+    c: Context,
+    python_versions: List[str] = (SUPPORTED_PYTHON_VERSIONS[0],),  # noqa # type: ignore
+    pytest_args: List[str] = [],  # noqa
+):
     """Run tests"""
-    echo_header(f"{Emo.TEST} Running tests")
+    # Invoke requires lists as type hints, but does not support lists as default arguments.
+    # Hence this super weird type hint and default argument for the python_versions arg.
+    echo_header(f"{msg_type.TEST} Running tests")
+
+    python_version_strings = [f"py{v.replace('.', '')}" for v in python_versions]
+    python_version_arg_string = ",".join(python_version_strings)
+
+    if not pytest_args:
+        pytest_args = [
+            "tests",
+            "-n auto",
+            "-rfE",
+            "--failed-first",
+            "-p no:cov",
+            "--disable-warnings",
+            "-q",
+        ]
+
+    pytest_arg_str = " ".join(pytest_args)
+
     test_result: Result = c.run(
-        "pytest -n auto -rfE --failed-first -p no:cov --disable-warnings -q",
+        f"tox -e {python_version_arg_string} -- {pytest_arg_str}",
         warn=True,
-        pty=True,
+        pty=NOT_WINDOWS,
     )
 
     # If "failed" in the pytest results
-    if "failed" in test_result.stdout:
+    failed_tests = [line for line in test_result.stdout if line.startswith("FAILED")]
+
+    if len(failed_tests) > 0:
+        print("\n\n\n")
+        echo_header("Failed tests")
         print("\n\n\n")
         echo_header("Failed tests")
-
-        # Get lines with "FAILED" in them from the .pytest_results file
-        failed_tests = [
-            line for line in test_result.stdout if line.startswith("FAILED")
-        ]
 
         for line in failed_tests:
             # Remove from start of line until /test_
@@ -261,10 +374,10 @@ def test(c: Context):
 
             # Keep only that after ::
             line_sans_suffix = line_sans_prefix[line_sans_prefix.find("::") + 2 :]
-            print(f"FAILED {Emo.FAIL} #{line_sans_suffix}     ")
+            print(f"FAILED {msg_type.FAIL} #{line_sans_suffix}     ")
 
     if test_result.return_code != 0:
-        exit(0)
+        exit(test_result.return_code)
 
 
 def test_for_rej():
@@ -272,7 +385,7 @@ def test_for_rej():
     rej_files = list(Path(".").rglob("*.rej"))
 
     if len(rej_files) > 0:
-        print(f"\n{Emo.FAIL} Found .rej files leftover from cruft update.\n")
+        print(f"\n{msg_type.FAIL} Found .rej files leftover from cruft update.\n")
         for file in rej_files:
             print(f"    /{file}")
         print("\nResolve the conflicts and try again. \n")
@@ -281,7 +394,7 @@ def test_for_rej():
 
 @task
 def lint(c: Context, auto_fix: bool = False):
-    """Lint the project using the pre-commit hooks and mypy."""
+    """Lint the project."""
     test_for_rej()
     pre_commit(c=c, auto_fix=auto_fix)
     static_type_checks(c)
@@ -292,7 +405,7 @@ def pr(c: Context, auto_fix: bool = False):
     """Run all checks and update the PR."""
     add_and_commit(c)
     lint(c, auto_fix=auto_fix)
-    test(c)
+    test(c, python_versions=SUPPORTED_PYTHON_VERSIONS)
     update_branch(c)
     update_pr(c)
 
